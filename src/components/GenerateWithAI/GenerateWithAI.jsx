import styles from './GenerateWithAI.module.scss';
import React, { useState, useEffect, useCallback } from 'react';
import { usePromptManager } from 'hooks/story/usePromptManager';
import { NewPromptSection } from 'components/PromptSection/NewPromptSection';
import { GeneratedImagesSection } from 'components/GenerateWithAI/GeneratedImagesSection/GeneratedImagesSection';
import { GenerationModeToggle } from 'components/GenerationModeToggle/GenerationModeToggle';
import { GenerationControlsSection } from 'components/GenerationControlsSection/GenerationControlsSection';
import { ImageSelectionForVideo } from 'components/ImageSelectionForVideo/ImageSelectionForVideo';
import { GenerateAIModeComponent } from 'components/GenerateWithAiSection/GenerateAIModeComponent';
import {
  useAddImageMutation,
  useTextToVideoMutation,
  usePolloImageToVideoMutation,
} from '../../redux/stories/storyApi';
import { StoreContext } from '../../mobx';
import { useSceneManager } from 'hooks/story/useSceneManager';
import { generateImage } from 'utils/ai/leonardoApi';
import { generateImageModelsLab } from 'utils/ai/modelslab';
import videoModelsData from 'data/videoModels.json';
import { useDispatch, useSelector } from 'react-redux';
import {
  updateSelectedImage,
  updateScene,
  addPromptVersion,
} from '../../redux/scene/sceneSlice';
import { setActiveScene } from '../../redux/scene/sceneSlice';
import { toggleImageReaction } from '../../redux/stories/storiesSlice';
import { user } from '../../redux/auth';
import { selectCurrentStory } from '../../redux/stories/storiesSlice';
import { useError } from 'contexts/ErrorContext';

const GenerateWithAI = ({
  scene,
  storyData,
  hasTitle = true,
  autoGenerate = false,
  activeTab = 'Image',
  galleryColumns,
}) => {
  const dispatch = useDispatch();
  const { username } = useSelector(user);
  const currentStory = useSelector(selectCurrentStory);
  const { showInfoPositive, showError } = useError();

  // Use currentStory from Redux for reactivity, fallback to storyData prop
  const reactiveStoryData = currentStory || storyData;
  const {
    onGenerateNegativePrompt,
    onGeneratePrompt,
    isPromptLoading,
    isNegativePromptLoading,
  } = usePromptManager();
  const [localPrompt, setLocalPrompt] = useState('');
  const [localNegativePrompt, setLocalNegativePrompt] = useState('');
  const [selectedImages, setSelectedImages] = useState([]);
  const [apiTokens, setApiTokens] = useState(0);
  const [showSkeletons, setShowSkeletons] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [checkingSkeletons, setCheckingSkeletons] = useState(false);
  const [isGenerationComplete, setIsGenerationComplete] = useState(false);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);

  // Track manual unassign to prevent auto-selection in RulerItem
  const [isManuallyUnassigned, setIsManuallyUnassigned] = useState(false);

  // Helper to get current model based on generation mode
  const getCurrentModel = () => {
    const isVideoMode =
      generationMode === 'textToVideo' || generationMode === 'imageToVideo';
    return isVideoMode ? videoModel : imageModel;
  };

  // Video generation states
  const [isVideoGenerating, setIsVideoGenerating] = useState(false);
  const [showVideoSkeletons, setShowVideoSkeletons] = useState(false);
  const [isVideoGenerationComplete, setIsVideoGenerationComplete] =
    useState(false);

  // Generation mode state
  const [generationMode, setGenerationMode] = useState('textToImage');

  // Generation controls state
  const [aspectRatio, setAspectRatio] = useState('16:9');
  const [resolution, setResolution] = useState('1080p');
  const [duration, setDuration] = useState('5s');
  const [quantity, setQuantity] = useState(1);
  const [imageModel, setImageModel] = useState(''); // No default for images
  const [videoModel, setVideoModel] = useState('pollo-v1-6'); // Default video model
  const [preset, setPreset] = useState('realistic');
  const [provider, setProvider] = useState('leonardo');
  const [showAdvancedSettings, setShowAdvancedSettings] = useState(false);

  const [addImage] = useAddImageMutation();
  const store = React.useContext(StoreContext);
  const { onGenerateImageByBot } = useSceneManager();

  const [textToVideo] = useTextToVideoMutation();
  const [polloImageToVideo] = usePolloImageToVideoMutation();

  // Image to video states
  const [selectedImageForVideo, setSelectedImageForVideo] = useState(null);
  const [selectedImageTail, setSelectedImageTail] = useState(null);
  const [videoLength, setVideoLength] = useState(5);
  const [videoGenerationType, setVideoGenerationType] = useState('text'); // 'text' or 'image'

  // Gallery toggle state
  const [activeGalleryTab, setActiveGalleryTab] = useState('All');

  // Gallery tabs configuration
  const galleryTabs = [
    { label: 'All', active: true },
    { label: 'Image', active: true },
    { label: 'Video', active: true },
    { label: 'Overlay', active: false },
    { label: 'Audio', active: false },
  ];

  // Handle gallery tab change
  const handleGalleryTabClick = tab => {
    setActiveGalleryTab(tab);
  };

  // Handle image rating for generated images
  const onRateImg = useCallback(
    async (imageId, action, imageUrl) => {
      try {
        // Find the generation that contains this image
        const generation = reactiveStoryData?.images?.find(gen =>
          gen.generated_images?.some(
            img => img.id === imageId || img._id === imageId
          )
        );

        if (generation) {
          // Use the correct ID field (id or _id)
          const generationId = generation.id || generation._id;

          dispatch(
            toggleImageReaction({
              imageId: imageId,
              generationId: generationId,
              username,
              reactionType: action,
            })
          );
        }
      } catch (error) {
        console.error('Error rating image:', error);
      }
    },
    [dispatch, reactiveStoryData, username]
  );

  const handleImageSelection = image => {
    setSelectedImages(prevSelections => {
      const isSelected = prevSelections.some(item => item.url === image.url);

      if (isSelected) {
        // Always remove the image if it is already selected
        const newSelections = prevSelections.filter(
          item => item.url !== image.url
        );
        localStorage.setItem('imageSelections', JSON.stringify(newSelections));
        return newSelections;
      } else {
        // If single select mode, replace the entire selection
        const newSelections = [...prevSelections, image];
        localStorage.setItem('imageSelections', JSON.stringify(newSelections));
        return newSelections;
      }
    });
  };

  useEffect(() => {
    if (scene?.prompt !== undefined) {
      setLocalPrompt(scene.prompt);
    }
    if (scene?.negative_prompt !== undefined) {
      setLocalNegativePrompt(scene.negative_prompt);
    }
  }, [scene?.prompt, scene?.negative_prompt]);

  const getImagesByOwner =
    (scene &&
      reactiveStoryData?.images?.length > 0 &&
      reactiveStoryData?.images
        .filter(
          (image, index, self) =>
            self.findIndex(img => img.id === image.id) === index
        )
        .filter(image => image.owner === scene._id)) ||
    [];

  const pointImages =
    getImagesByOwner &&
    getImagesByOwner
      .filter(
        (image, index, self) =>
          self.findIndex(img => img.id === image.id) === index
      )
      .map(el => {
        const { generated_images, id, ...rest } = el;

        return generated_images.map(img => ({
          ...rest,
          ...img,
          generationId: id,
        }));
      })
      .flat();

  // Auto-generate image when autoGenerate prop is true and scene has prompt but no image
  useEffect(() => {
    const hasSelectedImage = scene?.selectedImage?.url;
    const hasAnyGeneratedImages = pointImages.length > 0;
    const hasAnyPendingImages = pointImages.some(
      img =>
        img.status === 'PENDING' ||
        img.status === 'NEW' ||
        img.status === 'INWORK'
    );

    if (
      autoGenerate &&
      !hasAutoGenerated &&
      scene?.prompt &&
      scene.prompt.trim() !== '' &&
      !hasSelectedImage && // No selected image
      !hasAnyGeneratedImages && // No generated images at all
      !hasAnyPendingImages && // No pending images
      !isGenerating &&
      !showSkeletons
    ) {
      setHasAutoGenerated(true);

      // Use the appropriate generation method based on story provider
      if (reactiveStoryData?.generationProvider === 'leonardo') {
        onGenerateImageLeonardo();
      } else if (reactiveStoryData?.generationProvider === 'modelslab') {
        onGenerateImageModelsLab();
      } else {
        onGetImageImageLeonardoApi();
      }
    }
  }, [
    autoGenerate,
    hasAutoGenerated,
    scene?.prompt,
    scene?.selectedImage?.url,
    pointImages.length,
    pointImages, // Add full pointImages dependency to catch status changes
    isGenerating,
    showSkeletons,
    reactiveStoryData?.generationProvider,
  ]);

  // Reset auto-generation flag when scene changes
  useEffect(() => {
    setHasAutoGenerated(false);
  }, [scene?._id]);

  useEffect(() => {
    if (!scene) {
      return;
    }

    const shouldShowSkeletons =
      (getImagesByOwner.length > 0 &&
        getImagesByOwner.some(image => image.status === 'PENDING')) ||
      [].some(
        status =>
          status.pointId === scene._id &&
          (status.status === 'NEW' ||
            status.status === 'INWORK' ||
            (status.status === 'DONE' && scene.length === 0))
      );

    if (shouldShowSkeletons) {
      setShowSkeletons(true);
      if (isGenerating && !checkingSkeletons) {
        setCheckingSkeletons(true);
      }
    } else {
      setShowSkeletons(false);
      if (checkingSkeletons) {
        setIsGenerating(false);
        setCheckingSkeletons(false);
        setIsGenerationComplete(true);
      }
    }
  }, [
    getImagesByOwner,
    scene,
    pointImages?.length,
    isGenerating,
    checkingSkeletons,
  ]);

  const onPromptInputChange = e => {
    const value = e.target.value;
    setLocalPrompt(value);
  };

  const onPromptBlur = () => {
    // Use addPromptVersion to maintain version history
    if (localPrompt !== scene.prompt) {
      dispatch(
        addPromptVersion({
          sceneId: scene._id,
          prompt: localPrompt,
          isNegative: false,
        })
      );
    }
  };

  const onNegativeInputChange = e => {
    const value = e.target.value;
    setLocalNegativePrompt(value);
  };

  const onNegativePromptBlur = () => {
    // Use addPromptVersion to maintain version history
    if (localNegativePrompt !== scene.negative_prompt) {
      dispatch(
        addPromptVersion({
          sceneId: scene._id,
          prompt: localNegativePrompt,
          isNegative: true,
        })
      );
    }
  };

  const onGeneratePrompts = async isNegativePrompt => {
    try {
      if (isNegativePrompt) {
        const result = await onGenerateNegativePrompt({
          storyId: reactiveStoryData._id,
          sceneData: scene,
          storyText: reactiveStoryData.text,
        });
        setLocalNegativePrompt(result.data.negative_prompt);
        dispatch(
          updateScene({
            sceneId: scene._id,
            updates: { negative_prompt: result.data.negative_prompt },
          })
        );
        dispatch(
          setActiveScene({
            ...scene,
            negative_prompt: result.data.negative_prompt,
          })
        );
        showInfoPositive(
          'Negative prompt moderated',
          "Your negative prompt was flagged for moderation. We've rephrased it to ensure it meets our guidelines."
        );
      } else {
        const result = await onGeneratePrompt({
          storyId: reactiveStoryData._id,
          sceneData: scene,
          storyText: reactiveStoryData.text,
        });
        setLocalPrompt(result.data.prompt);
        dispatch(
          updateScene({
            sceneId: scene._id,
            updates: { prompt: result.data.prompt },
          })
        );
        dispatch(
          setActiveScene({
            ...scene,
            prompt: result.data.prompt,
          })
        );
        showInfoPositive(
          'Prompt moderated',
          "Your prompt was flagged for moderation. We've rephrased it to ensure it meets our guidelines."
        );
      }
    } catch (error) {
      console.error('Error generating prompt:', error);
      const message = isNegativePrompt
        ? 'Failed to generate negative prompt'
        : 'Failed to generate prompt';
      showError(message);
    }
  };

  const onCheckedButtonClick = async ({ el, sceneId, sceneData }) => {
    if (!el) {
      setIsManuallyUnassigned(true);
    } else {
      setIsManuallyUnassigned(false);
    }

    dispatch(
      updateSelectedImage({
        sceneId,
        selectedImage: el
          ? {
              id: el._id,
              url: el.googleCloudUrl,
              minUrl: el.minGoogleCloudUrl,
              prompt: el.prompt || '',
              negativePrompt: el.negativePrompt || el.negative_prompt || '',
              imageHeight: el.imageHeight,
              imageWidth: el.imageWidth,
            }
          : null,
      })
    );

    // Only update canvas if we have a valid image element
    if (el && sceneData) {
      store.updateCanvasImage({
        url: el.googleCloudUrl,
        minUrl: el.minGoogleCloudUrl,
        pointId: sceneData._id,
        imageId: el._id,
      });
    }
  };

  const tagHistory = scene?.tagHistory || [];

  const filteredTagHistory = tagHistory.reduce((acc, current) => {
    // For deletions
    if (current.action === 'DELETE') {
      // Check if this tag was ever added in the history
      const wasEverAdded = acc.some(
        item =>
          (item.action === 'ADD' || item.action === 'UPDATE') &&
          (item.tag?.new?._id === current.tag.old._id ||
            item.tag?.old?._id === current.tag.old._id)
      );

      // If tag was ever added or updated, remove all entries with this tag ID
      if (wasEverAdded) {
        return acc.filter(
          item =>
            item.tag?.new?._id !== current.tag.old._id &&
            item.tag?.old?._id !== current.tag.old._id
        );
      }

      // If tag was never added, keep the deletion
      acc.push(current);
      return acc;
    }

    // For additions or updates
    const existingTagIndex = acc.findIndex(
      item =>
        item.tag?.new?._id === current.tag?.new?._id ||
        item.tag?.old?._id === current.tag?.new?._id
    );

    if (existingTagIndex !== -1) {
      // Replace existing entry with new one
      acc[existingTagIndex] = current;
    } else {
      // Add new entry
      acc.push(current);
    }

    return acc;
  }, []);

  const onGenerateImageLeonardo = () => {
    setIsGenerating(true);
    setIsGenerationComplete(false);
    setCheckingSkeletons(false);
    onGenerateImageByBot({
      storyData: reactiveStoryData,
      sceneId: scene._id,
      negative_prompt: scene.negative_prompt,
      prompt: scene.prompt,
    });
  };

  const onGetImageImageLeonardoApi = async () => {
    try {
      setIsGenerating(true);
      setIsGenerationComplete(false);
      setCheckingSkeletons(false);
      let image = null;

      // Prepare generation parameters
      const generationParams = {
        ...scene,
        width: reactiveStoryData.resolution.width,
        height: reactiveStoryData.resolution.height,
        preset: reactiveStoryData.generationStyle?.preset,
        style: reactiveStoryData.generationStyle?.style,
        quantity: quantity,
      };

      // Override with selected model if available
      if (imageModel) {
        generationParams.modelId = imageModel;
      }

      // Override with selected preset if available
      if (preset && preset !== 'realistic') {
        generationParams.preset = preset;
      }

      image = await generateImage(generationParams);

      if (image) {
        addImage({
          image: { ...image, storyId: reactiveStoryData._id, owner: scene._id },
        });
      } else {
        throw new Error('No image was generated');
      }
    } catch (error) {
      setIsGenerating(false);
      setCheckingSkeletons(false);
    }
  };

  const onGenerateImageModelsLab = () => {
    setIsGenerating(true);
    setIsGenerationComplete(false);
    setCheckingSkeletons(false);

    // Prepare generation parameters
    const generationParams = {
      storyId: reactiveStoryData._id,
      pointId: scene._id,
      negative_prompt: scene.negative_prompt,
      prompt: scene.prompt,
      quantity: quantity,
    };

    // Add model if selected
    if (imageModel) {
      generationParams.modelId = imageModel;
    }

    // Add preset if selected
    if (preset && preset !== 'realistic') {
      generationParams.preset = preset;
    }

    generateImageModelsLab(generationParams);
  };

  const onGenerateVideoPollo = async () => {
    try {
      setIsVideoGenerating(true);
      setIsVideoGenerationComplete(false);
      setShowVideoSkeletons(true);

      // Get selected video model data
      const selectedVideoModel =
        videoModelsData.video_models.find(
          videoModelData => videoModelData.id === videoModel
        ) || videoModelsData.video_models[0]; // Fallback to first model

      // Convert duration to number (remove 's' suffix)
      const lengthInSeconds = parseInt(duration.replace('s', ''));

      await textToVideo({
        prompt: scene.prompt,
        aspectRatio: aspectRatio || currentStory.orientation,
        resolution: resolution,
        length: lengthInSeconds,
        modelId: selectedVideoModel?.id,
        prefix: selectedVideoModel?.prefix,
        storyId: reactiveStoryData._id,
        sceneId: scene._id,
      });

      // Video generation initiated successfully
      // The skeleton will remain until webhook updates the video status
    } catch (error) {
      setIsVideoGenerating(false);
      setShowVideoSkeletons(false);
    }
  };

  // Helper function to get image URL for video generation
  const getImageUrlForVideo = image => {
    if (!image) return null;

    // Leonardo API images already have HTTPS URLs
    return image.googleCloudUrl || image.url;
  };

  const onGenerateImageToVideo = async () => {
    try {
      setIsVideoGenerating(true);
      setIsVideoGenerationComplete(false);
      setShowVideoSkeletons(true);

      // Ensure we have at least one image selected
      if (!selectedImageForVideo) {
        throw new Error(
          'Please select at least one image for video generation'
        );
      }

      // Get selected video model data
      const selectedVideoModel =
        videoModelsData.video_models.find(
          videoModelData => videoModelData.id === videoModel
        ) || videoModelsData.video_models[0]; // Fallback to first model

      // Get URLs for images (already HTTPS from Leonardo API)
      const imageUrl = getImageUrlForVideo(selectedImageForVideo);
      const imageTailUrl = getImageUrlForVideo(selectedImageTail);

      // Convert duration to number (remove 's' suffix)
      const lengthInSeconds = parseInt(duration.replace('s', ''));

      await polloImageToVideo({
        image: imageUrl,
        prompt: scene.prompt || '',
        imageTail: imageTailUrl,
        length: lengthInSeconds,
        aspectRatio: aspectRatio,
        resolution: resolution,
        modelId: selectedVideoModel?.id,
        prefix: selectedVideoModel?.prefix,
        storyId: reactiveStoryData._id,
        sceneId: scene._id,
      });

      // Video generation initiated successfully
      // The skeleton will remain until webhook updates the video status
    } catch (error) {
      setIsVideoGenerating(false);
      setShowVideoSkeletons(false);
      // You might want to show an error message to the user here
    }
  };

  useEffect(() => {
    if (showSkeletons && isGenerating) {
      setIsGenerating(false);
    }
  }, [showSkeletons]);

  // Track manual unassign - when scene has no image but has generated images
  useEffect(() => {
    // Only set manually unassigned if selectedImage is explicitly null (not undefined)
    // and we have generated images available
    if (scene?.selectedImage === null && pointImages.length > 0) {
      setIsManuallyUnassigned(true);
    } else if (scene?.selectedImage?.url) {
      setIsManuallyUnassigned(false);
    }
    // Don't change isManuallyUnassigned state if selectedImage is undefined
  }, [scene?.selectedImage, pointImages.length]);

  // Video selection handler
  const onVideoSelect = video => {
    // TODO: Implement video selection logic similar to image selection
    // This would involve updating the scene with selected video data
    // For now, just log the selection
  };

  // Image selection handlers for video generation
  const onSelectImageForVideo = image => {
    setSelectedImageForVideo(image);
  };

  const onSelectImageTail = image => {
    setSelectedImageTail(image);
  };

  const onRemoveImageFromVideo = type => {
    if (type === 'main') {
      setSelectedImageForVideo(null);
    } else if (type === 'tail') {
      setSelectedImageTail(null);
    }
  };

  // Get videos for current scene
  const getVideosByOwner =
    (scene &&
      reactiveStoryData?.video?.length > 0 &&
      reactiveStoryData?.video.filter(video => video.sceneId === scene._id)) ||
    [];

  // Check if videos are still processing
  useEffect(() => {
    const hasPendingVideos = getVideosByOwner.some(
      video => video.status === 'waiting' || video.status === 'processing'
    );

    setShowVideoSkeletons(hasPendingVideos);

    // If we were generating and now no pending videos, mark as complete
    if (isVideoGenerating && !hasPendingVideos && getVideosByOwner.length > 0) {
      setIsVideoGenerating(false);
      setIsVideoGenerationComplete(true);
    }
  }, [getVideosByOwner, isVideoGenerating]);

  // Handle generation mode change
  const handleGenerationModeChange = mode => {
    setGenerationMode(mode);
    // No need for auto-switching - models are separate
  };

  // Handle generation controls changes
  const handleAspectRatioChange = ratio => {
    setAspectRatio(ratio);
  };

  const handleResolutionChange = res => {
    setResolution(res);
  };

  const handleDurationChange = dur => {
    setDuration(dur);
  };

  const handleQuantityChange = qty => {
    setQuantity(qty);
  };

  const handleModelChange = modelValue => {
    const isVideoMode =
      generationMode === 'textToVideo' || generationMode === 'imageToVideo';
    if (isVideoMode) {
      setVideoModel(modelValue);
    } else {
      setImageModel(modelValue);
    }
  };

  const handlePresetChange = presetValue => {
    setPreset(presetValue);
  };

  const handleProviderChange = providerValue => {
    setProvider(providerValue);
  };

  const handleToggleAdvancedSettings = () => {
    setShowAdvancedSettings(prev => !prev);
  };

  // Generate button logic
  const handleGenerateClick = () => {
    // Handle different generation modes
    switch (generationMode) {
      case 'textToImage':
        if (reactiveStoryData?.generationProvider === 'leonardo') {
          onGenerateImageLeonardo();
        } else if (reactiveStoryData?.generationProvider === 'modelslab') {
          onGenerateImageModelsLab();
        } else {
          onGetImageImageLeonardoApi();
        }
        break;

      case 'textToVideo':
        onGenerateVideoPollo();
        break;

      case 'imageToVideo':
        onGenerateImageToVideo();
        break;

      case 'imageToImage':
        // This mode is disabled, but adding for completeness
        break;

      default:
        // Fallback to original logic
        if (activeTab === 'Video') {
          if (videoGenerationType === 'image') {
            onGenerateImageToVideo();
          } else {
            onGenerateVideoPollo();
          }
        } else {
          if (reactiveStoryData?.generationProvider === 'leonardo') {
            onGenerateImageLeonardo();
          } else if (reactiveStoryData?.generationProvider === 'modelslab') {
            onGenerateImageModelsLab();
          } else {
            onGetImageImageLeonardoApi();
          }
        }
    }
  };

  // Generate button disabled state
  const isGenerateDisabled = (() => {
    const disabled = (() => {
      switch (generationMode) {
        case 'textToImage':
          return (
            !scene?.prompt ||
            scene.prompt.trim() === '' ||
            showSkeletons ||
            isGenerating
          );

        case 'textToVideo':
          return (
            !scene?.prompt ||
            scene.prompt.trim() === '' ||
            showVideoSkeletons ||
            isVideoGenerating
          );

        case 'imageToVideo':
          return (
            !selectedImageForVideo || showVideoSkeletons || isVideoGenerating
          );

        case 'imageToImage':
          return true; // Always disabled

        default:
          // Fallback to original logic
          return activeTab === 'Video' && videoGenerationType === 'image'
            ? !selectedImageForVideo || showVideoSkeletons || isVideoGenerating
            : activeTab === 'Video' && videoGenerationType === 'text'
            ? !scene?.prompt ||
              scene.prompt.trim() === '' ||
              showVideoSkeletons ||
              isVideoGenerating
            : !scene?.prompt ||
              scene.prompt.trim() === '' ||
              showSkeletons ||
              isGenerating;
      }
    })();

    return disabled;
  })();

  // Generate button loading state
  const isGenerateLoading = (() => {
    switch (generationMode) {
      case 'textToImage':
        return isGenerating || showSkeletons;
      case 'textToVideo':
      case 'imageToVideo':
        return isVideoGenerating || showVideoSkeletons;
      default:
        return activeTab === 'Video'
          ? isVideoGenerating || showVideoSkeletons
          : isGenerating || showSkeletons;
    }
  })();

  return (
    <div className={styles.wraper}>
      {/* {hasTitle && (
        <h1 className={styles.title}>
          Generate {activeTab === 'Video' ? 'video' : 'image'}
        </h1>
      )} */}
      <div>
        <div className={styles.generationModeContainer}>
          <GenerationModeToggle
            activeMode={generationMode}
            onModeChange={handleGenerationModeChange}
          />
        </div>

        {/* Image Selection for Image to Video */}
        {generationMode === 'imageToVideo' && (
          <ImageSelectionForVideo
            selectedImageForVideo={selectedImageForVideo}
            selectedImageTail={selectedImageTail}
            onSelectImageForVideo={onSelectImageForVideo}
            onSelectImageTail={onSelectImageTail}
            onRemoveImageFromVideo={onRemoveImageFromVideo}
            pointImages={pointImages}
          />
        )}
        <div className={styles.prompt_container}>
          <NewPromptSection
            localPrompt={localPrompt}
            localNegativePrompt={localNegativePrompt}
            onPromptInputChange={onPromptInputChange}
            onNegativeInputChange={onNegativeInputChange}
            onPromptBlur={onPromptBlur}
            onNegativePromptBlur={onNegativePromptBlur}
            isPromptLoading={isPromptLoading}
            isNegativePromptLoading={isNegativePromptLoading}
            onGeneratePrompts={onGeneratePrompts}
            tagHistory={filteredTagHistory}
            storyData={reactiveStoryData}
            scene={scene}
            generationMode={generationMode}
            selectedModel={getCurrentModel()}
          />
        </div>
        <GenerationControlsSection
          aspectRatio={aspectRatio}
          onAspectRatioChange={handleAspectRatioChange}
          resolution={resolution}
          onResolutionChange={handleResolutionChange}
          duration={duration}
          onDurationChange={handleDurationChange}
          quantity={quantity}
          onQuantityChange={handleQuantityChange}
          model={getCurrentModel()}
          onModelChange={handleModelChange}
          preset={preset}
          onPresetChange={handlePresetChange}
          provider={provider}
          onProviderChange={handleProviderChange}
          generationMode={generationMode}
          showAdvancedSettings={showAdvancedSettings}
          onToggleAdvancedSettings={handleToggleAdvancedSettings}
          onGenerateClick={handleGenerateClick}
          isGenerateDisabled={isGenerateDisabled}
          isGenerateLoading={isGenerateLoading}
          isGenerationComplete={(() => {
            switch (generationMode) {
              case 'textToImage':
                return isGenerationComplete;
              case 'textToVideo':
              case 'imageToVideo':
                return isVideoGenerationComplete;
              default:
                return activeTab === 'Video'
                  ? isVideoGenerationComplete
                  : isGenerationComplete;
            }
          })()}
        />
      </div>
      {/* Unified Gallery with Toggle */}
      <div className={styles.gallerySection}>
        {/* Gallery Mode Toggle */}
        <div className={styles.galleryModeToggle}>
          <GenerateAIModeComponent
            tabs={galleryTabs}
            activeTab={activeGalleryTab}
            handleTabClick={handleGalleryTabClick}
          />
        </div>

        {/* Unified Gallery Content */}
        {activeGalleryTab === 'Overlay' ? (
          <div className={styles.comingSoon}>
            <h3>Overlay Gallery</h3>
            <p>Coming soon...</p>
          </div>
        ) : activeGalleryTab === 'Audio' ? (
          <div className={styles.comingSoon}>
            <h3>Audio Gallery</h3>
            <p>Coming soon...</p>
          </div>
        ) : (
          <GeneratedImagesSection
            storyData={reactiveStoryData}
            activeScene={scene}
            promptsStatuses={[]}
            apiTokens={apiTokens}
            showGeneration={true}
            onCheckedButtonClick={onCheckedButtonClick}
            handleImageSelection={handleImageSelection}
            selectedImages={selectedImages}
            showSkeletons={showSkeletons}
            getImagesByOwner={getImagesByOwner}
            galleryColumns={galleryColumns}
            pointImages={pointImages}
            onRateImg={onRateImg}
            tagHistory={filteredTagHistory}
            hasMaxHeight={hasTitle}
            // Gallery filtering
            activeGalleryTab={activeGalleryTab}
            // Generation quantity for skeletons
            generationQuantity={quantity}
            // Video data
            showVideoSkeletons={showVideoSkeletons}
            onVideoSelect={onVideoSelect}
            videoGenerationType={
              generationMode === 'imageToVideo' ? 'image' : 'text'
            }
            setVideoGenerationType={setVideoGenerationType}
            selectedImageForVideo={selectedImageForVideo}
            selectedImageTail={selectedImageTail}
            onSelectImageForVideo={onSelectImageForVideo}
            onSelectImageTail={onSelectImageTail}
            onRemoveImageFromVideo={onRemoveImageFromVideo}
            videoLength={videoLength}
            setVideoLength={setVideoLength}
          />
        )}
      </div>
      {!hasTitle && <div className={styles.shadow} />}
    </div>
  );
};

export { GenerateWithAI };
